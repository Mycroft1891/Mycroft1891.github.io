---
title: 100 Days of Code Logs
permalink: 100DaysOfCode
---

As the days progress I will keep this blog post up to date as a change log to keep track of what I did on each day of the challenge.

# Index:

1. [Day 0](#day-0-january-1st)
2. [Day 1](#day-1-january-2nd)
3. [Day 2](#day-2-january-3rd)
4. [Day 3](#day-3-january-4th)

# Day 0: January 1st

Today I started and finished a Calculator Project using Plain Javascript, the main challenge were not the operations but working with the UI. Some of the main problems were:

* update the numbers typed in and the result at the right time
* get the right values from the button
* differentiate between numbers and operators as well special operators (=, remove)
* validate the input so that the app doesn't end up with multiple operators (ex: +++-4)

I have to say that day after day, I'm starting to feel more comfortable using Javascript with ES6 syntax.

<p data-height="342" data-theme-id="0" data-slug-hash="vpZXVK" data-default-tab="js,result" data-user="mr-moon" data-embed-version="2" data-pen-title="Calculator in plain Javascript" class="codepen">See the Pen <a href="https://codepen.io/mr-moon/pen/vpZXVK/">Calculator in plain Javascript</a> by Alexander Luna (<a href="https://codepen.io/mr-moon">@mr-moon</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>


# Day 1: January 2nd

Today I worked on the Ruby Exercises from `The Odin Project` ([found here](https://github.com/Mycroft1891/learn_ruby)) and completed them all. I also completed the first 3 exercises of `The Euler project`. While working with Prime Numbers in Ruby I noticed that the Prime Number validator `Prime.prime?(n)` is actually slow and I spend some time reading the `Ruby` language repository and found out that their algorithm to determine whether a number is a prime or not is about 3x slower than the algorithm I found on the internet while searching for better algorithms. I compared the build in prime method from Ruby with this algorithm:

{% highlight ruby%}
def isprime?(n)
  return false if n ==1
  return true if n == 2 || n == 3
  return false if n % 2 == 0 || n % 3 == 0

  i = 5
  w = 2

  while i * i <= n
      return false if n % i == 0
      i += w
      w = 6 - w
  end

  return true
end
{% endhighlight%}

I tested both `Prime.prime?(n)` and `isprime?(n)` with 1,000,000 numbers, the results are quite surprising:

{% highlight bash %}

ruby prime_tester.rb
(Prime) Time to complete (1 mil): 9.670435
(Prime) 78498 prime numbers found

(isprime?) Time to complete (1 mil): 2.173219
(isprime?) 78498 prime numbers found
{% endhighlight %}

This might be a future contribution to the Ruby Language but for now it requires more testing.

And that wraps up day 1


## Day 2: January 3rd

Today I spend most of the time building a blog using `Ruby on Rails 5`. I already have experience building apps using Rails 4 which I'm currently using in production which is why I'm working on upgrading to Rails 5. The is live available thanks to Heroku here: [https://immense-cove-36319.herokuapp.com/](https://immense-cove-36319.herokuapp.com/ )


## Day 3: January 4th

I build a Pomodoro clock with a graphical user interface in pure Javascript. I like the idea of a Pomodoro clock and would like to make a desktop version using `electron` in the coming days. More on that later.

As I mentioned in a previous post I was working on a contribution to the `Ruby Language` to reduce the `Prime:prime?` processing time. Currently my pull request is still pending but it passed all local tests and specs as well as `appveyor` integration tests and `travis-ci` integration tests. Over all I'm happy with my contribution so far although I had to do 2 quick fixes because of stupid errors I made to make it work.

And that pretty much wraps up day 4 of the challenge.
